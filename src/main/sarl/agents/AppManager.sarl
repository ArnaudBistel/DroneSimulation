package agents

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.javafx.AppExit

import gui.DroneBody
import gui.WarehouseBody
import controller.MainWindowController
import map.SimulationMap
import gui.DroneBody
import gui.WarehouseBody
import actionparam.MoveActionParams
import gui.Body

import java.util.UUID
import org.arakhne.afc.math.geometry.d2.i.Point2i
import java.util.ArrayList
import java.util.List
import map.MapPoint
import map.MapPointType
import java.util.Arrays
import java.text.DecimalFormat
import java.util.Map
import java.util.TreeMap
import solutionSolver.simulatedAnnealing.SimulatedAnnealing
import solutionSolver.SolutionSolver
import solutionSolver.simulatedAnnealing.SimulatedAnnealingAnalyser
import gui.Client
import java.util.Random
import utils.variables.SimulationParameters
import java.util.HashSet

/** 
 * @author arnaud
 * 
 */
agent AppManager {
	uses Logging, Lifecycle, DefaultContextInteractions, Schedules

	var map : SimulationMap
	var perceptionMap : ArrayList<ArrayList<Body>>
	var nbRowCell = 0
	var nbColCell = 0
	var nbCell = 0

	var stepTime = 30
	var stepCounter = 0

	var controller : MainWindowController
	var width : Integer
	var height : Integer
	val perceptionDistance : int = 200

	val warehouseNb = 1

	var actionList = new ArrayList<Action>

	var droneList : Map<UUID, DroneBody> = new TreeMap<UUID, DroneBody>
	var warehouseList : Map<UUID, WarehouseBody> = new TreeMap<UUID, WarehouseBody>
	var objectsList : Map<UUID, Body> = new TreeMap<UUID, Body>
	var random : Random

	on Initialize {
		synchronized (this) {
			this.controller = occurrence.parameters.get(0) as MainWindowController
			this.width = this.controller.width as Integer
			this.height = this.controller.height as Integer
			this.random = new Random
			
			this.perceptionMap = new ArrayList<ArrayList<Body>>
			this.nbRowCell = Math.ceil(this.height as Double / SimulationParameters.perceptionMapCellSize) as Integer
			this.nbColCell = Math.ceil(this.width as Double / SimulationParameters.perceptionMapCellSize) as Integer
			this.nbCell = this.nbRowCell * this.nbColCell
			for (var i = 0 ; i < this.nbCell; i++){
				var tmp = new ArrayList<Body>
				this.perceptionMap.add(tmp)
			}
			
			
			var nbDrones = this.controller.nbDronesInput
			var nbEntrepots = this.controller.nbEntrepotsInput
			var nbClients = this.controller.nbClientsInput
			
			map = new SimulationMap(nbClients, nbEntrepots)
			for (wh : this.map.getWarehouses()) {
				var warehouseBody = new WarehouseBody(wh.position.x as int, wh.position.y as int, 30, 30)
				spawnInContextWithID(Warehouse, warehouseBody.id, defaultContext, warehouseBody, nbDrones, this.controller)
				controller.addBody(warehouseBody, "WAREHOUSE")
				this.warehouseList.put(warehouseBody.getId, warehouseBody as WarehouseBody)
			}
			for (cl : this.map.getClients()) {
				var client = new Client(cl)
				controller.addClient(client)
			}			
			every(this.stepTime)[newStep]

			// test Simulated annealing
			// SimulatedAnnealingAnalyser.test(map);
			// SimulatedAnnealingAnalyser.startAnalyzing("SimulatedAnnealing_outputs");
		}
	}


	on NewDrone {
		synchronized (this) {
			this.controller.addBody(occurrence.droneBody, "DRONE")
			this.droneList.put(occurrence.droneBody.getId, occurrence.droneBody as DroneBody)
			var body = occurrence.droneBody as DroneBody
			var rowCell = Math.floor(body.position.y / SimulationParameters.perceptionMapCellSize) as Integer
			var colCell = Math.floor(body.position.x / SimulationParameters.perceptionMapCellSize) as Integer
			var index = rowCell * this.nbColCell + colCell
			body.perceptionMapCellIndex = index
			this.perceptionMap.get(index).add(body)			
		}
	}

	on ActionEvent {
		synchronized (this) {
			this.actionList.add(occurrence.action)
		}
	}

	def newStep : void {
		synchronized (this) {
			applyActions(actionList, this.stepCounter)
			actionList.clear

			// perception de warehouse ?
			// On met Ã  jour la perception de chaque agent drone
			for (e : getDronePerceptions.entrySet) {
				var eventPerception = new DronePerception(e.key, e.value, this.stepCounter)
				emit(eventPerception)[it.getID == e.key]
			}
			
			// test livraison
			if (this.stepCounter % 100 == 0) {
				var rd = this.random.nextInt(this.controller.clients.size)
				this.controller.clients.get(rd).delivered = true
			}
			
			this.stepCounter++
		}
	}

	def applyActions(actionList : List<Action>, step : int) {
		for (action : actionList) {
			if (action.type == ActionType.MOVE) {
				var params = action.params as MoveActionParams
				var dronebody = this.droneList.get(params.droneId)
				var x = params.x
				var y = params.y
				if (x<0){
					x = 0	
				}
				if (x>= this.width){
					x = this.width -1
				}
				if (y < 0){
					y = 0
				}
				if (y >= this.height){
					y = this.height - 1 
				}
				dronebody.move(x, y)
				var rowCell = Math.floor(dronebody.position.y / SimulationParameters.perceptionMapCellSize) as Integer
				var colCell = Math.floor(dronebody.position.x / SimulationParameters.perceptionMapCellSize) as Integer
				var index = rowCell * this.nbColCell + colCell
				if (dronebody.perceptionMapCellIndex != index){
					this.perceptionMap.get(dronebody.perceptionMapCellIndex).remove(dronebody)
					this.perceptionMap.get(index).add(dronebody)
					dronebody.perceptionMapCellIndex = index
				}			
			}
		}
	}

	def getDronePerceptions() : Map<UUID, List<Body>> {
		synchronized (this) {
			var ret = new TreeMap<UUID, List<Body>>
			for (body : this.droneList.entrySet) {
				var perceived = new ArrayList<Body>
				var cellIndex = body.value.perceptionMapCellIndex
				var perceivedIndexes = new HashSet<Integer>
				perceivedIndexes.add(cellIndex)
				var leftCol = Arrays.asList(cellIndex - 1,
						cellIndex - this.nbColCell - 1,
						cellIndex + this.nbColCell - 1) 
				var rightCol = Arrays.asList(cellIndex +1,
						cellIndex - this.nbColCell +1,
						cellIndex + this.nbColCell + 1)
				var topRow = Arrays.asList(cellIndex - this.nbColCell,
						cellIndex - this.nbColCell + 1,
						cellIndex - this.nbColCell - 1)
				var bottomRow = Arrays.asList(cellIndex + this.nbColCell,
						cellIndex + this.nbColCell + 1,
						cellIndex + this.nbColCell - 1)
				perceivedIndexes.addAll(leftCol)
				perceivedIndexes.addAll(rightCol)
				perceivedIndexes.addAll(topRow)
				perceivedIndexes.addAll(bottomRow)
				//info("X : " + body.value.position.x + " -- Y : " + body.value.position.y + " ----  Cell Index : " + cellIndex)
				if (cellIndex < this.nbColCell){
					perceivedIndexes.removeAll(topRow)
						// info("Remove Top Row")
				
				}
				if (cellIndex >= this.nbCell - this.nbColCell){
					perceivedIndexes.removeAll(bottomRow)
						// info("Remove Bottom Row")
					
				}
				if (cellIndex % this.nbColCell == 0){
					perceivedIndexes.removeAll(leftCol)
						// info("Remove Left Col")
				}
				if (cellIndex % this.nbColCell == this.nbColCell - 1){
					perceivedIndexes.removeAll(rightCol)
						// info("Remove Right Col")
				}
				// info(perceivedIndexes.size)
				for (index : perceivedIndexes) {
					perceived.addAll(this.perceptionMap.get(index))
				}
				perceived.remove(body.value)
				info(perceived.size)
				ret.put(body.key, perceived)
			}
			return ret
		}
	}

	on AppExit {
		info("App is exiting")
		killMe
	}

}
