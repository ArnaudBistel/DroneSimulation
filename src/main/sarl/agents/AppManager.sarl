package agents

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.javafx.AppExit

import gui.DroneBody
import gui.WarehouseBody
import controller.MainWindowController
import map.SimulationMap
import gui.DroneBody
import gui.WarehouseBody
import actionparam.MoveActionParams
import actionparam.DepositActionParams
import gui.Body

import java.util.UUID
import org.arakhne.afc.math.geometry.d2.i.Point2i
import java.util.ArrayList
import java.util.List
import map.MapPoint
import map.MapPointType
import java.util.Arrays
import java.text.DecimalFormat
import java.util.Map
import java.util.TreeMap
import solutionSolver.simulatedAnnealing.SimulatedAnnealing
import solutionSolver.SolutionSolver
import solutionSolver.simulatedAnnealing.SimulatedAnnealingAnalyser
import gui.Client
import java.util.Random
import utils.variables.SimulationParameters
import java.util.HashSet
import java.util.Set

/** 
 * @author arnaud
 * 
 */
agent AppManager {
	uses Logging, Lifecycle, DefaultContextInteractions, Schedules

	var map : SimulationMap
	var perceptionMap : ArrayList<ArrayList<Body>>
	var nbRowCell = 0
	var nbColCell = 0
	var nbCell = 0

	var stepTime = 30
	var stepCounter = 0

	var controller : MainWindowController
	var width : Integer
	var height : Integer
	val perceptionDistance : int = 200

	val warehouseNb = 1

	var actionList = new ArrayList<Action>

	var droneList : Map<UUID, DroneBody> = new TreeMap<UUID, DroneBody>
	var warehouseList : Map<UUID, WarehouseBody> = new TreeMap<UUID, WarehouseBody>
	var objectsList : Map<UUID, Body> = new TreeMap<UUID, Body>
	var random : Random

	on Initialize {
		synchronized (this) {
			info("AppManager restart")
			this.controller = occurrence.parameters.get(0) as MainWindowController
			this.width = this.controller.width as Integer
			this.height = this.controller.height as Integer
			this.random = new Random
			
			this.perceptionMap = new ArrayList<ArrayList<Body>>
			this.nbRowCell = Math.ceil(this.height as Double / SimulationParameters.perceptionMapCellSize) as Integer
			this.nbColCell = Math.ceil(this.width as Double / SimulationParameters.perceptionMapCellSize) as Integer
			this.nbCell = this.nbRowCell * this.nbColCell
			for (var i = 0 ; i < this.nbCell; i++){
				var tmp = new ArrayList<Body>
				this.perceptionMap.add(tmp)
			}
			
			
			var parameters = this.controller.parameters
			// true pour simulation, false pour multitests 
			var simulation = parameters.get(0) as Boolean
			// true pour recuit simulé, false pour q-learning 
			var recuit = parameters.get(1) as Boolean 
			// List de Float, taille 1 ou 2 (cas d'un range pour multitests)
			var nbDrones = parameters.get(2) as List<Float> 
			// List de Float, taille 1 ou 2 (cas d'un range pour multitests)
			var nbEntrepots = parameters.get(3) as List<Float>
			// List de Float, taille 1 ou 2 (cas d'un range pour multitests)
			var nbClients = parameters.get(4) as List<Float>
			// List de Float, taille 1 ou 2 (cas d'un range de poids de colis)
			var poidsColis = parameters.get(5) as List<Float>
			// Temperature intiale ou Range de température si recuit, alpha si qlearning
			var param1 = parameters.get(6) as List<Float>
			// alpha si recuit, gamme si qlearning
			var param2 = parameters.get(7) as Float
			// nombre d'itérations par palier si recuit, epsilon si qlearning
			var param3 = parameters.get(8) as Float
			
			map = new SimulationMap(nbClients.get(0) as int, nbEntrepots.get(0) as int)

			var simulatedAnnealing = new SimulatedAnnealing(map);
			var solution = simulatedAnnealing.Solve();
			
			if (simulation) {
				for (wh : this.map.getWarehouses()) {
					// Get delivery from this warehouse
					var deliveryList = new ArrayList<List<MapPoint>>
					for (i : solution) {
						if (i.get(0).equals(wh)) {
							deliveryList.add(i)
						}
					}
					var warehouseBody = new WarehouseBody(wh.position.x as int, wh.position.y as int, 30, 30)
					spawnInContextWithID(Warehouse, warehouseBody.id, defaultContext, warehouseBody, nbDrones.get(0) as int, this.controller)
					controller.addBody(warehouseBody, "WAREHOUSE")
					this.warehouseList.put(warehouseBody.getId, warehouseBody as WarehouseBody)
					var eventDeliveryList = new SendDeliveryList(deliveryList)
					info("event : " + eventDeliveryList)
					emit(eventDeliveryList)[it.getID == warehouseBody.id]
				}
				for (cl : this.map.getClients()) {
					var client = new Client(cl)
					controller.addClient(client)
				}	
				
				every(this.stepTime)[newStep]	
			}

			// test Simulated annealing
			// SimulatedAnnealingAnalyser.test(map);
			// SimulatedAnnealingAnalyser.startAnalyzing("SimulatedAnnealing_outputs");
		}
	}


	on NewDrone {
		synchronized (this) {
			this.controller.addBody(occurrence.droneBody, "DRONE")
			this.droneList.put(occurrence.droneBody.getId, occurrence.droneBody as DroneBody)
			var body = occurrence.droneBody as DroneBody
			var rowCell = Math.floor(body.position.y / SimulationParameters.perceptionMapCellSize) as Integer
			var colCell = Math.floor(body.position.x / SimulationParameters.perceptionMapCellSize) as Integer
			var index = rowCell * this.nbColCell + colCell
			body.perceptionMapCellIndex = index
			this.perceptionMap.get(index).add(body)			
		}
	}

	on ActionEvent {
		synchronized (this) {
			this.actionList.add(occurrence.action)
		}
	}

	def newStep : void {
		synchronized (this) {
			if (this.controller.started) {
				// TODO send to warehouse the order to assign roads
				for (wh : warehouseList.keySet()) {
					var warehouseBody = warehouseList.get(wh)
					var pathAssignment = new MakeAssignmentPaths()
					emit(pathAssignment)[it.getID == warehouseBody.id]
		        }
				
				applyActions(actionList, this.stepCounter)
				actionList.clear
	
				// perception de warehouse ?
				// On met à jour la perception de chaque agent drone
				for (e : getDronePerceptions.entrySet) {
					var eventPerception = new DronePerception(e.key, e.value, this.stepCounter)
					emit(eventPerception)[it.getID == e.key]
				}
				
				// test livraison
				/*if (this.stepCounter % 100 == 0) {
					var rd = this.random.nextInt(this.controller.clients.size)
					this.controller.clients.get(rd).delivered = true
				}*/
				
				this.stepCounter++
				
			} else {
				emit(new Destroy)
				
			}
			
			
		}
	}

	def applyActions(actionList : List<Action>, step : int) {
		for (action : actionList) {
			if (action.type == ActionType.MOVE) {
				var params = action.params as MoveActionParams
				var dronebody = this.droneList.get(params.droneId)
				var x = params.x
				var y = params.y
				if (x<0){
					x = 0	
				}
				if (x>= this.width){
					x = this.width -1
				}
				if (y < 0){
					y = 0
				}
				if (y >= this.height){
					y = this.height - 1 
				}
				dronebody.move(x, y)
				var rowCell = Math.floor(dronebody.position.y / SimulationParameters.perceptionMapCellSize) as Integer
				var colCell = Math.floor(dronebody.position.x / SimulationParameters.perceptionMapCellSize) as Integer
				var index = rowCell * this.nbColCell + colCell
				if (dronebody.perceptionMapCellIndex != index){
					this.perceptionMap.get(dronebody.perceptionMapCellIndex).remove(dronebody)
					this.perceptionMap.get(index).add(dronebody)
					dronebody.perceptionMapCellIndex = index
				}			
			} else if (action.type == ActionType.DEPOSIT) {
				var params = action.params as DepositActionParams
				var x = params.x
				var y = params.y
				var client = 0
				var i = 0
				for (cl : this.controller.clients) {
					if (cl.getMapPoint().position.getX() == x && cl.getMapPoint().position.getY() == y) {
						client = i
					}		
					i = i+1		
				}
				this.controller.clients.get(client).delivered = true
			}
		}
	}

	def getDronePerceptions() : Map<UUID, List<Body>> {
		synchronized (this) {
			var ret = new TreeMap<UUID, List<Body>>
			for (body : this.droneList.entrySet) {
				var perceived = new ArrayList<Body>
				var cellIndex = body.value.perceptionMapCellIndex
				var perceivedIndexes = new HashSet<Integer>
				perceivedIndexes.add(cellIndex)
				var leftCol = Arrays.asList(cellIndex - 1,
						cellIndex - this.nbColCell - 1,
						cellIndex + this.nbColCell - 1) 
				var rightCol = Arrays.asList(cellIndex +1,
						cellIndex - this.nbColCell +1,
						cellIndex + this.nbColCell + 1)
				var topRow = Arrays.asList(cellIndex - this.nbColCell,
						cellIndex - this.nbColCell + 1,
						cellIndex - this.nbColCell - 1)
				var bottomRow = Arrays.asList(cellIndex + this.nbColCell,
						cellIndex + this.nbColCell + 1,
						cellIndex + this.nbColCell - 1)
				perceivedIndexes.addAll(leftCol)
				perceivedIndexes.addAll(rightCol)
				perceivedIndexes.addAll(topRow)
				perceivedIndexes.addAll(bottomRow)
				//info("X : " + body.value.positixon.x + " -- Y : " + body.value.position.y + " ----  Cell Index : " + cellIndex)
				if (cellIndex < this.nbColCell){
					perceivedIndexes.removeAll(topRow)
						// info("Remove Top Row")
				
				}
				if (cellIndex >= this.nbCell - this.nbColCell){
					perceivedIndexes.removeAll(bottomRow)
						// info("Remove Bottom Row")
					
				}
				if (cellIndex % this.nbColCell == 0){
					perceivedIndexes.removeAll(leftCol)
						// info("Remove Left Col")
				}
				if (cellIndex % this.nbColCell == this.nbColCell - 1){
					perceivedIndexes.removeAll(rightCol)
						// info("Remove Right Col")
				}
				// info(perceivedIndexes.size)
				for (index : perceivedIndexes) {
					perceived.addAll(this.perceptionMap.get(index))
				}
				perceived.remove(body.value)
				//info(perceived.size)
				ret.put(body.key, perceived)
			}
			return ret
		}
	}


	on Destroy {
		info("AppManager destroy")
		killMe
	}

	on AppExit {
		info("App is exiting")
		killMe
	}

}
