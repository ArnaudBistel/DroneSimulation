package agents

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules

import gui.DroneBody
import gui.WarehouseBody
import controller.MainWindowController
import map.SimulationMap
import gui.DroneBody
import gui.WarehouseBody
import actionparam.MoveActionParams
import gui.Body

import java.util.UUID
import org.arakhne.afc.math.geometry.d2.i.Point2i
import java.util.ArrayList
import java.util.List
import map.MapPoint
import map.MapPointType
import java.util.Arrays
import java.text.DecimalFormat
import java.util.Map
import java.util.TreeMap
import solutionSolver.simulatedAnnealing.SimulatedAnnealing
import solutionSolver.SolutionSolver
import solutionSolver.simulatedAnnealing.SimulatedAnnealingAnalyser
import gui.Client
import java.util.Random

/** 
 * @author arnaud
 * 
 */
agent AppManager {
	uses Logging, Lifecycle, DefaultContextInteractions, Schedules

	var map : SimulationMap

	var stepTime = 30
	var stepCounter = 0

	var controller : MainWindowController
	var width : Integer
	var height : Integer
	val perceptionDistance : int = 200

	val warehouseNb = 1

	var actionList = new ArrayList<Action>

	var droneList : Map<UUID, DroneBody> = new TreeMap<UUID, DroneBody>
	var warehouseList : Map<UUID, WarehouseBody> = new TreeMap<UUID, WarehouseBody>
	var objectsList : Map<UUID, Body> = new TreeMap<UUID, Body>
	var random : Random

	on Initialize {
		synchronized (this) {
			this.controller = occurrence.parameters.get(0) as MainWindowController
			this.width = this.controller.width as Integer
			this.height = this.controller.height as Integer
			this.random = new Random
			
			var nbDrones = this.controller.nbDronesInput
			var nbEntrepots = this.controller.nbEntrepotsInput
			var nbClients = this.controller.nbClientsInput
			
			map = new SimulationMap(nbClients, nbEntrepots)
			for (wh : this.map.getWarehouses()) {
				var warehouseBody = new WarehouseBody(wh.position.x as int, wh.position.y as int, 30, 30)
				spawnInContextWithID(Warehouse, warehouseBody.id, defaultContext, warehouseBody, nbDrones, this.controller)
				controller.addBody(warehouseBody, "WAREHOUSE")
				this.warehouseList.put(warehouseBody.getId, warehouseBody as WarehouseBody)
			}
			for (cl : this.map.getClients()) {
				var client = new Client(cl)
				controller.addClient(client)
			}			
			every(this.stepTime)[newStep]

			// test Simulated annealing
			// SimulatedAnnealingAnalyser.test(map);
			// SimulatedAnnealingAnalyser.startAnalyzing("SimulatedAnnealing_outputs");
		}
	}


	on NewDrone {
		synchronized (this) {
			this.controller.addBody(occurrence.droneBody, "DRONE")
			this.droneList.put(occurrence.droneBody.getId, occurrence.droneBody as DroneBody)
		}
	}

	on ActionEvent {
		synchronized (this) {
			this.actionList.add(occurrence.action)
		}
	}

	def newStep : void {
		synchronized (this) {
			applyActions(actionList, this.stepCounter)
			actionList.clear

			// perception de warehouse ?
			// On met Ã  jour la perception de chaque agent drone
			for (e : getDronePerceptions.entrySet) {
				var eventPerception = new DronePerception(e.key, e.value, this.stepCounter)
				emit(eventPerception)[it.getID == e.key]
			}
			
			// test livraison
			if (this.stepCounter % 100 == 0) {
				var rd = this.random.nextInt(this.controller.clients.size)
				this.controller.clients.get(rd).delivered = true
			}
			
			this.stepCounter++
		}
	}

	def applyActions(actionList : List<Action>, step : int) {
		for (action : actionList) {
			if (action.type == ActionType.MOVE) {
				var params = action.params as MoveActionParams
				var dronebody = this.droneList.get(params.droneId)
				dronebody.move(params.x, params.y)
			}
		}
	}

	def getDronePerceptions() : Map<UUID, List<Body>> {
		synchronized (this) {
			var ret = new TreeMap<UUID, List<Body>>
			for (body : this.droneList.entrySet) {
				var perceived = new ArrayList<Body>
				for (perceivedObject : this.droneList.values) {
					if (perceivedObject.id != body.value.id) {
						perceived.add(perceivedObject as Body)
					}
				}
				ret.put(body.key, perceived)
			}
			return ret
		}
	}

	on Destroy {
	}

}
